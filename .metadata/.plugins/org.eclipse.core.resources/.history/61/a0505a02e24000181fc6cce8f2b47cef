/*
 * uart.c
 *
 *  Created on: Mar 16, 2018
 *      Author: Cursos
 */

#include "UART.h"

static void UART_RTOS_Callback(UART_Type *base, uart_handle_t *state, status_t status, void *param)
{
	uart_handle_config *handle = (uart_handle_config *)param;
	BaseType_t xHigherPriorityTaskWoken, xResult;

	xHigherPriorityTaskWoken = pdFALSE;
	xResult = pdFAIL;

	if (status == kStatus_UART_RxIdle)
	{
		xResult = xEventGroupSetBitsFromISR(handle->rxEvent, RTOS_UART_COMPLETE, &xHigherPriorityTaskWoken);
	}
	else if (status == kStatus_UART_TxIdle)
	{
		xResult = xEventGroupSetBitsFromISR(handle->txEvent, RTOS_UART_COMPLETE, &xHigherPriorityTaskWoken);
	}

	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);

}


uint8_t background_buffer[32];

uint8_t background_buffer_b[32];


void uart_init(UART_Type * base, uart_handle_config * handle){
	//uint8_t initial;
	uart_config_t defcfg;
	uint32_t scrclock;
	uint8_t buffer;
	UART_GetDefaultConfig(&defcfg);
	handle->base = base;

	if(base == UART0){
		defcfg.baudRate_Bps = UART_BAUDRATE;
		defcfg.parityMode = kUART_ParityDisabled;
		scrclock = CLOCK_GetFreq(UART0_CLK_SRC);
		buffer = background_buffer;
		NVIC_SetPriority(UART0_RX_TX_IRQn, 5U);
	}else{
		defcfg.baudRate_Bps = UART_BAUDRATE_B;
		defcfg.parityMode = kUART_ParityDisabled;
		scrclock = CLOCK_GetFreq(UART3_CLK_SRC);
		buffer = background_buffer_b;
		NVIC_SetPriority(UART3_RX_TX_IRQn, 6U);
	}

	handle->txSemaphore = xSemaphoreCreateMutex();
	handle->rxSemaphore = xSemaphoreCreateMutex();
	handle->txEvent = xEventGroupCreate();
	handle->rxEvent = xEventGroupCreate();

	UART_Init(handle->base, &defcfg, scrclock);
	UART_TransferCreateHandle(handle->base, handle->t_state, UART_RTOS_Callback, handle);
	UART_TransferStartRingBuffer(handle->base, handle->t_state, buffer, sizeof(buffer));

	UART_EnableTx(handle->base, true);
	UART_EnableRx(handle->base, true);

}

void UART_userSend(uart_handle_config *handle, const uint8_t *buffer, uint32_t length)
{
	xSemaphoreTake(handle->txSemaphore, 0);


	handle->txTransfer.data = (uint8_t *)buffer;
	handle->txTransfer.dataSize = (uint32_t)length;

	/* Non-blocking call */
	UART_TransferSendNonBlocking(handle->base, handle->t_state, &handle->txTransfer);

	xEventGroupWaitBits(handle->txEvent, RTOS_UART_COMPLETE, pdTRUE, pdFALSE, portMAX_DELAY);

	xSemaphoreGive(handle->txSemaphore);

}

void UART_userReceive(uart_handle_config *handle, const uint8_t *buffer, uint32_t length)
{

    EventBits_t ev;
    size_t n = 0;
    int retval = kStatus_Fail;
    size_t local_received = 0;

    if (NULL == handle->base)
    {
        /* Invalid handle. */
        return kStatus_Fail;
    }
    if (0 == length)
    {
        if (received != NULL)
        {
            *received = n;
        }
        return 0;
    }
    if (NULL == buffer)
    {
        return kStatus_InvalidArgument;
    }

    /* New transfer can be performed only after current one is finished */
    if (pdFALSE == xSemaphoreTake(handle->rxSemaphore, portMAX_DELAY))
    {
        /* We could not take the semaphore, exit with 0 data received */
        return kStatus_Fail;
    }

    handle->rxTransfer.data = buffer;
    handle->rxTransfer.dataSize = (uint32_t)length;

    /* Non-blocking call */
    UART_TransferReceiveNonBlocking(handle->base, handle->t_state, &handle->rxTransfer, &n);

    ev = xEventGroupWaitBits(handle->rxEvent,
                             RTOS_UART_COMPLETE | RTOS_UART_RING_BUFFER_OVERRUN | RTOS_UART_HARDWARE_BUFFER_OVERRUN,
                             pdTRUE, pdFALSE, portMAX_DELAY);
    if (ev & RTOS_UART_HARDWARE_BUFFER_OVERRUN)
    {
        /* Stop data transfer to application buffer, ring buffer is still active */
        UART_TransferAbortReceive(handle->base, handle->t_state);
        /* Prevent false indication of successful transfer in next call of UART_RTOS_Receive.
           RTOS_UART_COMPLETE flag could be set meanwhile overrun is handled */
        xEventGroupClearBits(handle->rxEvent, RTOS_UART_COMPLETE);
        retval = kStatus_UART_RxHardwareOverrun;
        local_received = 0;
    }
    else if (ev & RTOS_UART_RING_BUFFER_OVERRUN)
    {
        /* Stop data transfer to application buffer, ring buffer is still active */
        UART_TransferAbortReceive(handle->base, handle->t_state);
        /* Prevent false indication of successful transfer in next call of UART_RTOS_Receive.
           RTOS_UART_COMPLETE flag could be set meanwhile overrun is handled */
        xEventGroupClearBits(handle->rxEvent, RTOS_UART_COMPLETE);
        retval = kStatus_UART_RxRingBufferOverrun;
        local_received = 0;
    }
    else if (ev & RTOS_UART_COMPLETE)
    {
        retval = kStatus_Success;
        local_received = length;
    }

    /* Prevent repetitive NULL check */
    if (received != NULL)
    {
        *received = local_received;
    }

    /* Enable next transfer. Current one is finished */
    if (pdFALSE == xSemaphoreGive(handle->rxSemaphore))
    {
        /* We could not post the semaphore, exit with error */
        retval = kStatus_Fail;
    }
    return retval;

}




